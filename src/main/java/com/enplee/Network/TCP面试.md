

## TCP面试整理 [参考文档](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453143119&idx=2&sn=d9c8716af1606e939ed589a404baebc7&scene=21#wechat_redirect)

### 一. TCP基础(简述 TCP 的报文头部结构)

![图片](image\tcp头部格式.webp)

+ 序列号: 建立连接时候生成的随机数作为初始值，通过SYN包发送给接收端主机，每发送一次就累计一次数据的字节大小。用来表示数据包的次序，解决网络包乱序。
+ 确认应答号: 表示这个应答号之前的序列号数据都被接收了，用来解决不丢包的问题。
+ 控制位:

```
+ ACK: 该位为1时，确认应答。
+ RST: 为1时，表示TCP连接出现异常强制断开连接
+ SYN: 为1时，表示希望建立连接。
+ FIN: 为1时，表示希望断开连接。
```

+ 为什么需要TCP协议，TCP工作在哪一层？

```
TCP工作在传输层，下层的IP层数不可靠的，不保证可靠的数据包交付，也不保证数据包的顺序，更不保证数据包的完整。
所以，数据包传输的可靠性，完整性，有序性就要要传输层的TCP协议来保证。
```

+ 什么是TCP？(和UDP的区别)

```
TCP是面向连接的、可靠的、基于字节流的传输层通讯协议。
面向连接指的是：TCP传输面向一对一建立连接
可靠的是指: TCP保证了报文的可靠交付，包括可靠性、完整性、有序性。
字节流是指: TCP是二进制流的没有边界的，流是指传输是有序的。
```

```
TCP和UDP的区别和联系:TCP和UDP同属传输层
1. 连接 TCP面向连接传输，UDP不需建立连接直接传输
2. 对象 TCP一对一的传输，UDP支持一对一、一对多、多对多互相通信
3. 可靠性: TCP主张可靠交付，保证误差错、无重复、按需到达，UDP主张的是交付，尽最大努力交付，不保证可靠性。
4. 首部开销: TCP为了做到可靠等属性，首部长且不固定。UDP首部开销小，且固定
总结来说，UDP是为了交付效率，简单快速。TCP是为了交付可靠，需要牺牲开销和设计复杂的工序。
```

+ 什么是TCP连接？

```
官方定义: 用于保证可靠性和流量控制所维护的某些状态信息，包括序列号、socket、窗口大小。
实际上就是客户端需要与服务端基于以上是三个信息达成共识。

一个TCP连接可以通过双方的Socket标识: 原地址+源端口 | 目的地址+目的端口
TCP的连接上限: 理论上是allIP*allPort，但是受到文件描述fds数量的限制和内存容量的限制。
```

### 二. TCP链接的建立与断开

#### 三次握手

+ 三次握手过程

```
三次握手可以在第三次握手就发送数据了
```

+ 为什么要三次握手？两次？四次？

```
1. 三次握手首先确认了clit和server都有发送和接受的能力。
2. 只有三次握手才足够确立起连接，即对Socket、序列号和窗口大小达成共识。
	+ 三次握手才可以阻止历史重复连接建立请求的初始化
		如果clit第一次发送序列号为90的请求超时，又发送了100的请求，但是90比100先到了server，server正常做应答：ack=1，ack num= 91，但是clit会发91已经被抛弃了，所以会发送rst=1，重新建立连接。知道server接收到了100.重新尽力连接。
	+ 三次握手才可以同步双方的序列号
	一次和二次握手，双方同步了client的初始序列号，二次和三次握手，双方同步了server的序列号。
	+ 三次握手已经足够了，避免浪费资源
	第二次握手是复用了两次
```

```
两次无法防止历史连接的建立，client无法发送rst
四次多余，浪费资源
```

+ SYN攻击

```
攻击者伪造不同的IP对server发送建立连接请求SYN，server的ACK报文发送到未知ip无法得到应答，就会占满SYN接受队列(未连接队列)，server不能为正常用户提供服务。
解决方案：
	1. 调整参数，增加队列容量
	2. net.ipv4.tcp_syncookies = 1 启动syncookies模式，不进入队列
```

#### 四次挥手

+ 四次挥手过程

````

````

+ 为什么要四次挥手

```
1. 建立连接是双发同时建立起连接
2. 关闭连接时，首先发起fin的一方表示这一方已经没有数据发送了，但是另外一方的数据还没有处理完。
```

+ Time_wait状态的意义(四次挥手之后，连接会马上关闭嘛)

```
不会马上关闭，会进入Time_wait状态，时间是2MSL
1. 保证被动关闭客户端正常关闭，如果最后发送的ACK超时了，能顺利接受到被动关闭方的重发fin包。
2. 让老的数据包消散在网络中，不会被下一次建立起的连接接受，造成数据的错乱
```

+ Time_wait的影响(解决方案)

```
造成占用过多的端口号，无法建立连接。
复用socket，为socket打时间戳，但是要保证时间的一致。
```

### 三. TCP可靠传输(TCP 怎么保证可靠传输？) [参考](https://mp.weixin.qq.com/s?__biz=MzAwNDA2OTM1Ng==&mid=2453143215&idx=2&sn=e9e767ebcbd2fce4688ba71db4fbd32d&scene=21#wechat_redirect)

```
TCP通过序列号与确认应答、重传机制、滑动窗口、流量控制、拥塞控制等一些列机制保障可靠性
```

#### 重传机制

```
TCP通过序列号和确认应答作为实现可靠性的手段之一。
同时，通过应答也可以发丢包，如果丢包，就要引入重传机制
```

+ 超时重传

```
1. 如果长时间没有收到ACK，那么就会触发超时重传。
	数据包丢失会触发；
	ACK包丢失也会触发；
2. 判断超时的间隔判定:
	报文往返值RTT，超时重传时间要略大于RTT。
	RTT如何计算？ 通过采样加平均，同时要考虑到波动，还要采样波动范围。
3. 超时间隔加倍技术:
	如果再次超时，时间间隔加倍，两次超时就说明网络环境差，不宜发送。
	
问题: 超时周期较长
```

+ 快速重传

```
快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文

问题: 无法确定是重传多少包，比如ack nums == 2 * 3, 是只发送2还是2,3,4...
```

+ SACK(选择性确认)

```
可以将已经接受了包的信息发送给发送方，发送方就能只发送丢失的数据
```

#### 滑动窗口/流量控制

```
每一个数据包都需要一个应答，显然是低效的。引入滑动窗口的概念。窗口的大小就是无需应答也可以发送的数据包数量。
原理就是: 开辟一个缓冲，将滑动窗口中的数据缓存，如果全部ACK那么删除，否则就保存。
```

+ 窗口大小

```
接受端通知发送端自己缓冲区的接受能力，由发送方决定
接受端维护一个接受窗口，发送端维护一个发送窗口:发送窗口和可用窗口
```

#### 拥塞控制

```
在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…
```

+ 拥塞控制有哪些控制算法？
  + 慢启动

  ```
  当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小*2。
  ```

  + 拥塞避免

  ```
  当拥塞窗口 cwnd 「超过」慢启动门限 ssthresh 就会进入拥塞避免算法。
  ```

  + 拥塞发生

  ```
  出现重传，就认为网络拥堵。
  ssthresh 设为 cwnd/2
  cwnd 重置为 1,重新进行慢启动
  ```

  + 快速恢复

  ```
  发生开重传，进入快速恢复，窗口变为阈值+3，线性增长。
  ```

### 四. 冷门问题

+ 什么是半关闭、半打开、半连接

```
半关闭:四次挥手，主动发起一方，前两次挥手之后进入半关闭状态，有接受能力，无发送能力。
半连接:建立了一半的连接。就是三次握手，server迟迟收不到第三次ACK，阻塞在半连接状态。
半打开:建立了连接的双方，其中一方意外关闭，另外一方是感知不到的，处于半打开状态。
```

+ 对称加密与非对称加密、数字证书
+ 中间人攻击