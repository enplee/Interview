### linux设计笔记

### 文件系统

+ linux文件结构

```
linux中一切皆文件,linux将目录、磁盘、外部设备等都抽象成了文件。
文件:文件内容+管理信息(inode节点) inode节点中包含了文件的创建时间、修改时间、访问权限、文件长度和磁盘上的位置。
目录:内容是其他文件节点号和名字的文件。目录中的每个数据项都是包括其他文件的inode号、名称和指向该文件的连接。
删除目录中的文件,只是删除了数据项和连接数减一。如果一个文件的连接数为0,这个文件位置就会标记为可用空间。
```

+ 文件描述符与文件系统调用

```
文件描述符: 小值整数,通过open系统调用创建fds和文件的联系,就可以通过fds对文件进行访问。
write(int filds, const void *buf, size_t nbytes)
read(int filds, ocnst void *buf, size_t nbyutes) 
读写的系统调用通过fds对文件进行读写
open(const char path,int oflags ,mode_t mode) open为调用进程和文件建立起联系,这种联系通过fds返回。
fds是全局唯一的,不同进程对同一个文件open会获得不同的fds。写也是隔离的。
close(int filds) close会切断进程和文件的联系,同时释放fds.
```

+ mmap系统调用

```
mmap()的作用是允许程序共享内存.
同时mmap可以应用在文件的处理上,是的磁盘上的文件操作就像内存中的数组,进程对内存的操作会由os反应到磁盘上。
```

### 一 进程与信号

+ 什么是进程

```
一个运行着一个或者多个线程的地址空间和这些线程所需要的的系统资源，整在运行的程序实例就是一个进程。
```

+ 进程的结构

```
grep test text.txt
| pid : 进程的唯一标识,进程表的索引,2-32768取值,pid = 1的进程是init进程。
| code : 进程执行所需要的代码,通常多个进程共享一份代码
| 数据 : s = "test"
| 函数库 : c语言函数库,也是多个进程共享一份
| 文件

进程表: 保存linux内存中所有的进程的信息,通过pid进行索引 pd命令查看
```

+ 进程的创建

```
除了init进程,所有进程都是由其父进程进程创建。init进程是所有进程的祖先进程,进程的整体是树形结构。PPID:父进程的进程id
```

```c
// 复制进程应映像：让进程同时执行多个函数/多个操作使用fork() copyOnwrite思想
pid_t pid = fork();
// fork系统调用会复制当前进程,新进程的数据和代码和父进程完全相同,除了作为一个新进程的独特信息。
if(pid) == 1: // 当前执行的是父进程
if(pid) == 0: // 当前执行的是子进程
if(pid) == -1: // fork()失败。虚拟内存不足。
```

+ 僵尸进程

```c
// wait方法让父进程等待子进程结束,并获取子进程的运行状态。
pid_t pid = wait();
// 未被调用wait()方法的子进程会一直存在,即使已经执行结束,也会保存关键信息和占用pid。此时进入僵尸进程状态。
```

+ 进程的调度

```
linux的调度算法是分优先级的时间片调度机制。优先级高的进程会被分配到更多的时间片。
```

+ 信号Signal

```
信号是linux响应特定事件的一个约定,接受到信号的进程会采取相应的动作。信号一般是由错误产生的。
ctl+C是一个中断信号,如果进程未捕获,进程就会终止。
信号机制可以实现进程之间的通信,但是信号的内容有限。
```

```C
// 进程通过kill()系统调用发送信号给指定的进程
int kill(pid_t pid, int sig)
kill -9 pid 可以给pid的进程发送终止命令
```

### 二 进程通信：管道

+ 什么是管道

```
数据通过管道从一个进程流动到另外一个进程。 | 在linux shell中的管道。cmd1 | cmd2 --> cmd1::popen("cmd2"，open_Mod);
cmd1进程通过shell创建一个子进程cmd2,将标准输出连接到cmd2的标准输出.
```

+ 匿名管道pipe

```c
FILE *popen(const char *command, const char *open_mode)// 创建command子进程,并建立管道。
// 底层通过pipe、fork、excl()三个系统调用实现。
int pipe(int file_descriptor[2]);
// pipe传入一个fds[],fds[0]用来向pipe中读,fds[1]用来向pipe中写。FIFO。 但是fds是进程私有的。
pid_t pid = fork();
// fork()的子进程和父进程共享fds,已经打开的fds也对子进程开放,子进程实现了和父进程的数据交换。 此时父子进程执行相同的代码
exec(const char *path) 
// execl用来切换进程执行的代码,实现了两个不同进程之间的数据交换。
    
问题: 匿名管道只能在父子进程之间传递数据,具有局限性。
```

+ 命名管道FIFO

```c
// 为了在不相关进程之间传递数据,将FIFO设计成文件,称为命名管道。以一种特殊的文件形式存在。
mkfifo(const char *filename, mode_t mode)
// mkfifo调用之后,FIFO文件会作为正常文件挂载在path上,可以通过对FIFO文件的正常读写。
// 对空FIFO读,进程是会一直挂起的。
```

+ 信号量
+ 共享内存
+ 消息队列

### 三 进程通信: socket



